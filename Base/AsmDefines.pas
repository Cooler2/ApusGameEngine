unit AsmDefines;
interface

const
 // константы для флагов
 hasModRM = 1;
 hasSIB = 2;
 hasOffset8 = 4;
 hasOffset32 = 8;
 hasValue8 = 16;
 hasValue16 = 32;
 hasvalue32 = 64;
 hasValueOffset = hasOffset8+hasOffset32+hasValue8+hasValue16+hasValue32;
 canPack    = 128; // если значение можно сократить до байта

const
 // данные для заполнения промежутков в коде для выравнивания
 fillers:array[1..15,0..15] of byte=(
   ($90,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 1
   ($09,$C0,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 2
   ($80,$F3,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 3
   ($80,$F3,$00,$90,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 4
   ($0D,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 5
   ($81,$CB,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 6
   ($81,$CB,$00,$00,$00,$00,$90,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 7
   ($81,$CB,$00,$00,$00,$00,$09,$C0,$00,$00,$00,$00,$00,$00,$00,$00),  // 8
   ($81,$CB,$00,$00,$00,$00,$80,$F3,$00,$00,$00,$00,$00,$00,$00,$00),  // 9
   ($0D,$00,$00,$00,$00,$0D,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 10
   ($0D,$00,$00,$00,$00,$81,$CB,$00,$00,$00,$00,$00,$00,$00,$00,$00),  // 11
   ($81,$CB,$00,$00,$00,$00,$81,$CB,$00,$00,$00,$00,$00,$00,$00,$00),  // 12
   ($81,$CB,$00,$00,$00,$00,$0D,$00,$00,$00,$00,$09,$C0,$00,$00,$00),  // 13
   ($81,$CB,$00,$00,$00,$00,$09,$C0,$81,$CB,$00,$00,$00,$00,$00,$00),  // 14
   ($81,$CB,$00,$00,$00,$00,$80,$F3,$00,$81,$CB,$00,$00,$00,$00,$00)); // 15

type
 // Запись для команды
 TStatement=packed record
  offset:cardinal; // Начальный адрес (смещение)
  alignment:byte;  // как выравнивать (варианты 0,1,2,4,8 или 16)
  case kind:byte of      // 0 - команда, 1 - переменная
  0:(
    size:byte;    // размер команды
    prefCount:byte; // кол-во префиксов
    prefixes:array[0..3] of byte; // префиксы
    opcode:byte;  // опкод команды
    flags:byte;   // флаги наличия доп. полей
    modRM:byte;   // байт Mod/RM
    sib:byte;     // байт Scale-Index-Base
    offsetValue:integer; // значение смещения адреса
    value:integer;       // непосредственный операнд
    lab:smallint;        // номер метки (если используется, иначе: -1)
    labFor:byte;         // где используется метка: 1 - для offset, 2 - для value
    labcode:byte;        // альтернативный opcode (на случай упаковки значения)
  );
  1:(
    fullsize:word;     // Полный размер
    typesize:byte;     // Размер одного элемента (тип элемента)
    init:boolean;      // true если требуется инициализация
    initValue:array[0..9] of byte; // значение для инициализации
  );
 end;

 TLabel=record
  relative:boolean; // true, если это номер statement'а.
  defined:boolean; // true если адрес уже заполнен
  value:cardinal; // номер statement'а либо абсолютный адрес
 end;

implementation

end.
